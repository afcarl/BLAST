#include "Compiler.h"

Compiler::Compiler(MatshupSet* const ms, const char* tfn, uint32_t ssz, uint32_t hsz, float beta, float mix, 
		   uint32_t fsz, uint32_t fhop) :
  hop_size(hsz),
  shingle_size(ssz),
  frame_size(fsz),
  one_hop_in_samples(fhop),
  frame_hop(hop_size*fhop),
  samples_per_shingle(shingle_size * frame_size),
  qpos(0),
  beta(beta),
  mix(mix),
  targetSound(0),
  matshupSound(0),
  target_channels(0),
  outbuf(0),
  matshup(ms)
{
  initialize(tfn);  
}
  
Compiler::~Compiler(){
  delete[] outbuf;
  delete[] HammingWindow;
}

int Compiler::initialize(const char* targetFileName){  
  std::string str(targetFileName);
  if ( str.find(".") == std::string::npos) 
    iMatsh::error("Cannot get file extension from targetFileName %s.", targetFileName);  
  std::string matshupName(str.substr(0,str.find(".")));
  matshupName.append(".imatsh.wav");
  SF_INFO sfinfo;
  init_sfinfo(&sfinfo);
  open_audio_file(&targetSound, targetFileName, SFM_READ, &sfinfo);
  target_channels = sfinfo.channels;
  sfinfo.channels = MAX_CHANNELS;
  open_audio_file(&matshupSound, matshupName.c_str(), SFM_WRITE, &sfinfo);
  outbuf = new short[samples_per_shingle * sfinfo.channels];
  memset(outbuf, 0, samples_per_shingle*sizeof(short)*sfinfo.channels);
  HammingWindow = _make_hamming_window(samples_per_shingle);
  return EXIT_GOOD;
}

int Compiler::init_sfinfo(SF_INFO* sfinfo){
  sfinfo->frames = 0;
  sfinfo->samplerate = 0;
  sfinfo->channels = 0;
  sfinfo->format = 0;
  sfinfo->sections = 0;
  sfinfo->seekable = 0;
  return EXIT_GOOD;
}
int Compiler::empty(){
  return matshup->empty();
}

long Compiler::compile_next(){  
  NNresult r;
  r.query_pos = qpos;
  MitPair current_subset = matshup->equal_range(r);
  long numSamples = compile_audio_shingle( current_subset );
  write_outfile();
  update_outbuf();
  matshup->erase(current_subset.first, current_subset.second);
  qpos+=hop_size;
  return numSamples;
}

// Assume non-overlapping query_pos shingles with (shingle_size-1)*frame_hop + frame_size samples
// track_pos shingles can overlap
// overlap-add frame_size-frame_hop samples into next outputbuf
long Compiler::compile_audio_shingle( MitPair& mp ){
  Mit it = mp.first;
  long nSamples = 0;
  if( it != mp.second){
    short tbuf[samples_per_shingle * MAX_CHANNELS];
    short sbuf[samples_per_shingle * MAX_CHANNELS];
    memset(tbuf, 0, samples_per_shingle*MAX_CHANNELS*sizeof(short));
    memset(sbuf, 0, samples_per_shingle*MAX_CHANNELS*sizeof(short));
    long nTarget, nSource;
    float prob;
    float expNormDists = sum_exp_distances(mp, beta);
    float rmsTarget, rmsSource, smix = mix, amp=0;
    float eps = std::numeric_limits<float>::epsilon();
    NNresult r = *it;
    nTarget = read_audio_shingle(tbuf, targetSound, r.query_pos*one_hop_in_samples, samples_per_shingle, target_channels);
    window_audio_shingle(tbuf, samples_per_shingle);
    audio_shingle_to_outbuf(tbuf, 0.25*mix,  nTarget, 1); // Put in right channel
    rmsTarget = compute_RMS(tbuf, nTarget);
    while( it != mp.second ){
      r = *it++;
      nSource = read_audio_shingle(sbuf, r.media.c_str(), r.track_pos*one_hop_in_samples, samples_per_shingle);
      window_audio_shingle(sbuf, samples_per_shingle);
      nSamples = min( nTarget, nSource );
      if(nSamples){
	rmsSource = compute_RMS(sbuf, nSamples);
	if ( rmsTarget > eps && rmsSource > eps){
	  amp = rmsTarget / rmsSource;
	}
	else{
	  amp = 0.0f;
	}
	prob = expf( -beta * r.dist) / expNormDists;
	fprintf(stdout, "%f %f %f %d %d %d\n", fabs(r.dist), prob, amp*prob*smix, r.query_pos, r.track_pos, r.media_idx);
	audio_shingle_to_outbuf(sbuf, amp*prob*smix,  nSamples); // Put in left channel
      }
    }
  }
  return nSamples;
}

int Compiler::open_audio_file(SNDFILE **snd, const char* fname, int mode, SF_INFO* sfinfo){
  *snd = sf_open(fname, mode, sfinfo);
  if( ! *snd ){
    complete();
    char ebuf[MAXSTR];
    sf_error_str(*snd, ebuf, MAXSTR);
    iMatsh::error("SoundFile %s failed to open. %s", fname, ebuf);
  }
  if( sfinfo->channels > MAX_CHANNELS ){
    sf_close(*snd);
    *snd=0;
    complete();
    iMatsh::error("Unsupported channels: %d", sfinfo->channels);
  }
  return sfinfo->channels;
}

long Compiler::read_audio_shingle(short* buf, const char* file, long samp_start, long num_samps){
  SNDFILE* snd;
  SF_INFO sfinfo;
  init_sfinfo(&sfinfo);
  open_audio_file(&snd, file, SFM_READ, &sfinfo);
  long num_read = read_audio_shingle(buf, snd, samp_start, num_samps, sfinfo.channels);
  sf_close(snd);
  return num_read;
}

long Compiler::read_audio_shingle(short* buf, SNDFILE* snd, long samp_start, long num_samps, int channels){
  sf_seek(snd, samp_start, SEEK_SET);
  num_samps = sf_readf_short(snd, buf, num_samps);
  if(channels>1)
    to_mono(buf, num_samps, channels); // take channel 1 only
  return num_samps;
}

void Compiler::window_audio_shingle(short* buf, uint32_t num_samps){
  uint32_t n = num_samps;
  short* p = buf; 
  float* w = HammingWindow; 
  _apply_window(p, w, n);
}

inline void Compiler::_apply_window(short* p, float* w, uint32_t n){
  while(n--){
    *p = (short)(*p * *w) ;
    p++;
    w++;
  }
}

float* Compiler::_make_hamming_window(uint32_t num_samples){
  int M = num_samples;
  float* win = new float[num_samples];
  float* w = win;
  for(int n= 0; n<M; n++)
    *w++ = 0.5 - 0.5 * cos((2*M_PI*n)/(M-1));
  return win;
}

void Compiler::to_mono(short* buf, long num_samps, int channels){
  short *op = buf, *bp = buf;    
  while(num_samps--){
    *op = *bp;
    op++;
    bp+=channels;
  }
}

long Compiler::audio_shingle_to_outbuf(short *buf, float amp, long num_samps, int channel_offset){
  short *op = outbuf + channel_offset;
  long n = num_samps;
  if( amp > std::numeric_limits<float>::epsilon() )
    while(n--){
      *op += (short)(amp * *buf++);
      op+=MAX_CHANNELS;
    }
  return num_samps;
}

long Compiler::write_outfile(int last_frame){
  uint32_t num_written = 0;
  if(last_frame)
     num_written = sf_writef_short(matshupSound, outbuf, samples_per_shingle - frame_hop); 
  else
     num_written = sf_writef_short(matshupSound, outbuf, frame_hop); 
  if(!last_frame && num_written != frame_hop){
    complete();
    iMatsh::error("Short soundfile write in update_outbuf");
  }
  return num_written;
}

int Compiler::update_outbuf(){
  long n = samples_per_shingle;
  memmove( outbuf, outbuf + frame_hop * MAX_CHANNELS, (n - frame_hop) * sizeof(short) * MAX_CHANNELS );
  memset( outbuf + (n - frame_hop) * MAX_CHANNELS, 0, frame_hop * sizeof(short) * MAX_CHANNELS);
  return EXIT_GOOD;
}

float Compiler::sum_exp_distances(MitPair& mp, float beta){
  Mit it = mp.first;
  NNresult r;
  float d = 0.0f;
  while( it != mp.second ){
    r = *it++;
    d+= expf( -beta * r.dist );
  }
  return d;
}

float Compiler::compute_RMS(short* a, long n){
  float y = 0.f, x=0.f;
  long nn = n;
  while(nn--){
    x = (float)*a++;
    y += x*x;
  }
  float rms = sqrtf ( y / n );
  return rms;
}


int Compiler::complete(){
  // write remainder of last frame
  write_outfile(1);
  // close open file descriptors
  if(matshupSound)
    sf_close(matshupSound);
  if(targetSound)
    sf_close(targetSound);
  return EXIT_GOOD;
}
